demo()
"demo()"
demo()
help()
datasets::beaver2
plot.default(datasets::beaver1)
datasets::airquality
data(airpolution
)
data(airpolution)
data(airquality)
ls()
install.packages("Matching")
library(Matching)
data(lalonde)
columns(lalnde)
lalonde
max(lalonde[re74])
> max(lalonde(re74))
max(lalonde["re74"])
min(lalonde["re74"])
lolonde["74"].count(0)
count(lalonde["re74"], vars=0)
count.fields(lalonde["re74"], vars=0)
install.packages(table)
install.packages("COUNT")
count.fields(lalonde["re74"], vars = "0")
length(lalonde["re74"]==0)
length(lalonde["re74"])
length(lalonde["re74"] <5000) + length(lalonde["re74"] >10000)
length(lalonde["married"] == 1 and lalonde["educ"] >8)
> length(lalonde["married"] == 1 & lalonde["educ"] >8)
> sum((lalonde["re74"] <5000) | (lalonde["re74"] >10000)))
sum((lalonde['re74'] < 5000) | (lalonde['re74'] > 10000))
> sum((lalonde['re74'] <5000) | (lalonde['re74'] > 10000))
sum((lalonde["re74"] < 5000) | (lalonde["re74"] > 10000))
sin^2(1)
sin(1)^2
sin(1)^2
sin(1)
sin(1)^2
sin(1)
0.841471^2
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?lm
set.seed(1)
x = 1:99
ds = c(x*rnorm(99, 1, 0.2)) #original data-generating equation, using rnorm
lm1 = lm(ds ~ x) #fitting linear model to equation
summary.lm(lm1) #observe positive coefficient
plot(ds, xlab="x", ylab = "y", main = "Sensitivity of Linear Regression to outliers")
abline(lm1, col = 4, lwd=2) #generate scatter plot w. regression line
abline(lm2, col = "red", lwd=2) #generate scatter plot w. regression line for new ds
?lm
set.seed(1)
x = 1:99
ds = c(x*rnorm(99, 1, 0.2)) #original data-generating equation, using rnorm
lm1 = lm(ds ~ x) #fitting linear model to equation
summary.lm(lm1) #observe positive coefficient
ds2 = c(ds, -10000) # append large negative number to dataset
lm2 = lm(ds2 ~ c(x, 100)) # generate linear model for new dataset
plot(ds, xlab="x", ylab = "y", main = "Sensitivity of Linear Regression to outliers")
abline(lm1, col = 4, lwd=2) #generate scatter plot w. regression line
abline(lm2, col = "red", lwd=2) #generate scatter plot w. regression line for new ds
legend("bottomright", legend = c("Without outlier","With outlier"), col = c("blue", "red"), lty=1:1)
#summary.lm(lm2) # observe negative coefficient of lm
# Regression is very sensitive to outliers. The serves to show that the existance of a single outlier can be..
library(Matching)
data("lalonde")
attach(lalonde)
Y = lalonde$re78
Tr = lalonde$treat
X <- cbind(age, educ, black, hisp, married, nodegr, re74, re75, u74, u75)
BalanceMatrix <- cbind(age, I(age^2), educ, I(educ^2), black, hisp,
+ married, nodegr, re74, I(re74^2), re75, I(re75^2), u74, u75,
+ I(re74 * re75), I(age * nodegr), I(educ * re74), I(educ * re75))
genout <- GenMatch(Tr = Tr, X = X, BalanceMatrix = BalanceMatrix, wait.generations = 25, nboots = 100,
pop.size = 250, int.seed = 3818, unif.seed = 3527)
saveRDS(genout, "GeneticMatchingDiamond.rda")
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
MatchBalance(Tr ~ age + I(age^2) + educ + I(educ^2) + black + hisp +
+ married + nodegr + re74 + I(re74^2) + re75 + I(re75^2) + u74 + u75 +
+ I(re74 * re75) + I(age * nodegr) + I(educ * re74) + I(educ * re75),
data = lalonde, match.out = mout, nboots = 1000)
load("/Users/oscarengelbrektson/GeneticMatchingDiamond.rda")
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
MatchBalance(Tr ~ age + I(age^2) + educ + I(educ^2) + black + hisp +
+ married + nodegr + re74 + I(re74^2) + re75 + I(re75^2) + u74 + u75 +
+ I(re74 * re75) + I(age * nodegr) + I(educ * re74) + I(educ * re75),
data = lalonde, match.out = mout, nboots = 1000)
mout$est
library(Matching)
data("lalonde")
attach(lalonde)
library(rgenoud)
Y = lalonde$re78
Tr = lalonde$treat
X <- cbind(age, educ, black, hisp, married, nodegr, re74, re75, u74, u75)
BalanceMatrix <- cbind(age, I(age^2), educ, I(educ^2), black, hisp,
+ married, nodegr, re74, I(re74^2), re75, I(re75^2), u74, u75,
+ I(re74 * re75), I(age * nodegr), I(educ * re74), I(educ * re75))
genout <- GenMatch(Tr = Tr, X = X, BalanceMatrix = BalanceMatrix,
pop.size = 1000, int.seed = 3818, unif.seed = 3527)
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
readRDS("GeneticMatchingDiamond.rda")
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
fitness_func = function(w1,w2,w3,w4,w5){
loss = (treat[1,] - (w1*control1[1,] + w2*control2[1,] + w3*control3[1,] + w4*control4[1,] + w5*control5[1,]))^2
return(loss)
}
genoud(fitness_func, 4, domains = , boundary.enforcement = 1)
#Take units used as potential controls
#Remove "character"-type colums to allow multiplication
foo_covariates = foo[186:190,-c(1, ncol(foo1))]
readRDS("GeneticMatchingDiamond.rda")
setwd("~/Documents/GitHub/Synthetic-Matching")
readRDS("GeneticMatchingDiamond.rda")
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
fitness_func = function(w1,w2,w3,w4,w5){
loss = (treat[1,] - (w1*control1[1,] + w2*control2[1,] + w3*control3[1,] + w4*control4[1,] + w5*control5[1,]))^2
return(loss)
}
mout = Match(Y = Y, Tr = Tr, X = X, Weight.matrix = genout)
MatchBalance(Tr ~ age + I(age^2) + educ + I(educ^2) + black + hisp +
+ married + nodegr + re74 + I(re74^2) + re75 + I(re75^2) + u74 + u75 +
+ I(re74 * re75) + I(age * nodegr) + I(educ * re74) + I(educ * re75),
data = lalonde, match.out = mout, nboots = 1000)
mout$index.treated[1:10]
mout$index.control[1:10]
summary(mout)
mout$index.treated[1:10]
mout$index.control[1:10]
length(mout$index.treated)
for (i in 1:length(mout$index.treated)){
}
for (i in 1:length(mout$index.treated)){
treat <- lalonde[mout$index.treated[i],]
controls <- lalonde[mout$index.control[1+5*(i-1):i*5],]
fitness_func = function(w){
loss = treat[,c(1:11)] - (w[1]*controls[1,c(1:11)] + w[2]*controls[2,c(1:11)] + w[3]*controls[3,c(1:11)] + w[4]*controls[4,c(1:11)] + w[5]*controls[5,c(1:11)])
loss_squared <- loss*loss
return(sum(loss_squared))
}
domain_matrix <- cbind(rep(0,5),rep(1,5))
genoud <- genoud(fitness_func, nvars = 5, Domains = domain_matrix, boundary.enforcement = 2,
pop.size = 30,
wait.generations = 5, hard.generation.limit = 20)
}
length(mout$index.treated)
